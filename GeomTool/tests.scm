#!/usr/bin/guile -s
!#

(use-modules (gt-interface functions)
	     (gt-interface vector-helper)
	     (gt-interface gtlib)
	     (gt-interface shape-factory))

;; (gt-make-segmentlist2))
;; (gt-make-region2))
;; (gt-make-set2))

(define tests-ok #t)

(define assert-yell
  (lambda (val test-name)
    (if val
	(begin
	  (display "test ")
	  (display test-name)
	  (display " ok."))
	(begin
	  (set! tests-ok #f)
	  (display "HORRIBLE TERRIBLE FAILURE OF DOOM in ")
	  (display test-name)))
    (newline)))
		   
(define test-union-SLSL-1 		;two boundeds, result = 1 bounded
  ;; union of some boundeds
   (lambda ()
     (let ((L1 (gt-make-segmentlist2))
 	   (L2 (gt-make-segmentlist2))
 	   (S (gt-make-set2))
	   (LTest (gt-make-segmentlist2)))
       (factory-square L1 4)
       (factory-square L2 4)
       (assert-yell (gt-segmentlist2-almostequal L1 L2 #t) "test-union-SLSL-1.1")
       (gt-segmentlist2-translate L1 2 2)
       (gt-segmentlist2-translate L2 4 4)
       (gt-set2-union L1 L2 S)
       (factory-poly LTest '((0 0) (4 0) (4 2) (6 2) (6 6) (2 6) (2 4) (0 4) (0 0)))
       (assert-yell (gt-segmentlist2-almostequal LTest (gt-region2-list (gt-set2-region S 0) 0)) "test-union-SLSL-1.2")
       )))
(define test-union-SLSL-2 		;two holes, result = 1 hole
  ;; union of some holes
   (lambda ()
     (let ((L1 (gt-make-segmentlist2))
 	   (L2 (gt-make-segmentlist2))
 	   (S (gt-make-set2))
	   (LTest (gt-make-segmentlist2)))
       (factory-square L1 4)
       (factory-square L2 4)
       (gt-segmentlist2-invert L1)
       (gt-segmentlist2-invert L2)
       (assert-yell (gt-segmentlist2-almostequal L1 L2 #t) "test-union-SLSL-2.1")
       (gt-segmentlist2-translate L1 2 2) ;put radius 2 square at LL 0,0
       (gt-segmentlist2-translate L2 4 4) ;put radius 2 square at LL 1,1
       (gt-set2-union L1 L2 S)
       (factory-poly LTest '((2 2) (2 4) (4 4) (4 2) (2 2)))
       ;; (pk "L1" L1)
       ;; (pk "L2" L2)
       ;; (pk "S" S)
       ;; (pk "LTest" LTest)
       (assert-yell (equal? "UNBOUNDED" (gt-segmentlist2-gettype (gt-region2-list (gt-set2-region S 0) 0))) "test-union-SLSL-2.2")
       (assert-yell (gt-segmentlist2-almostequal LTest (gt-region2-list (gt-set2-region S 0) 1)) "test-union-SLSL-2.3")
       )))
(define test-union-SLSL-3		;two boundeds, result = 1 donut (bounded with hole in it
    ;; union of some holes
   (lambda ()
     (let ((L1 (factory-make-poly '((0 0) (2 0) (2 6) (0 6) (0 0))))
	   (L2 (factory-make-poly '((1 0) (6 0) (6 6) (1 6) (1 4) (4 4) (4 2) (1 2) (1 0))))
 	   (S (gt-make-set2))
	   (LHole (factory-make-poly '((2 2) (2 4) (4 4) (4 2) (2 2))))
	   (LBounded (factory-make-poly '((0 0) (6 0) (6 6) (0 6) (0 0)))))
       (gt-set2-union L1 L2 S)
       (assert-yell (equal? (gt-set2-numregions S) 1) "test-union-SLSL-3.1")
       (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 0)) 2) "test-union-SLSL-3.2")
       (assert-yell (gt-segmentlist2-almostequal (gt-segmentlist2-simplify (gt-region2-list (gt-set2-region S 0) 0 )) LBounded) "test-union-SLSL-3.3")
       (assert-yell (gt-segmentlist2-almostequal (gt-region2-list (gt-set2-region S 0) 1 ) LHole) "test-union-SLSL-3.4")
       )))
(define test-union-SLSL-4		;two boundeds, result = 2 boundeds, they're disjoint
    ;; union of some holes
   (lambda ()
     (let ((L1 (factory-make-poly '((0 0) (1 0) (1 1) (0 1) (0 0))))
	   (L2 (factory-make-poly '((2 2) (3 2) (3 3) (2 3) (2 2))))
 	   (S (gt-make-set2)))
       (gt-set2-union L1 L2 S)
       (assert-yell (equal? (gt-set2-numregions S) 2) "test-union-SLSL-4.1")
       (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 0)) 1) "test-union-SLSL-4.2")
       (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 1)) 1) "test-union-SLSL-4.3")
       ;; (pk "S" S)
       ;; (pk "S.r1" (gt-set2-region S 0))
       ;; (pk "S.r1.sl1" (gt-region2-list (gt-set2-region S 0) 0))
       ;; (pk "sim(S.r1.sl1)" (gt-segmentlist2-simplify (gt-region2-list (gt-set2-region S 0) 0)))
       (assert-yell (gt-segmentlist2-almostequal (gt-segmentlist2-simplify (gt-region2-list (gt-set2-region S 1) 0)) L1) "test-union-SLSL-4.4")
       (assert-yell (gt-segmentlist2-almostequal (gt-segmentlist2-simplify (gt-region2-list (gt-set2-region S 0) 0)) L2) "test-union-SLSL-4.5")
       )))
(define test-union-SLSL-5 		;two holes, result = unbounded
  (lambda ()
     (let ((L1 (factory-make-poly '((0 0) (0 1) (1 1) (1 0) (0 0))))
	   (L2 (factory-make-poly '((2 2) (2 3) (3 3) (3 2) (2 2))))
 	   (S (gt-make-set2)))
       (gt-set2-union L1 L2 S)
       (assert-yell (equal? (gt-set2-numregions S) 1) "test-union-SLSL-5.1")
       (assert-yell (equal? "UNBOUNDED" (gt-segmentlist2-gettype (gt-region2-list (gt-set2-region S 0) 0))) "test-union-SLSL-5.2")
       )))
(define test-union-SLSL-6 		;one hole, one bounded, result = negative donut
  (lambda ()
     (let ((L1 (factory-make-poly '((0 0) (0 3) (3 3) (3 0) (0 0))))
	   (L2 (factory-make-poly '((1 1) (2 1) (2 2) (1 2) (1 1))))
 	   (S (gt-make-set2)))
       ;; (pk "L1" L1)
       ;; (pk "L2" L2)
       (gt-set2-union L1 L2 S)
       ;; (pk "S" S)
       (assert-yell (equal? (gt-set2-numregions S) 2) "test-union-SLSL-6.1")
       (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 1)) 2) "test-union-SLSL-6.2")
       (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 0)) 1) "test-union-SLSL-6.3")
       (assert-yell (equal? "UNBOUNDED" (gt-segmentlist2-gettype (gt-region2-list (gt-set2-region S 1) 0))) "test-union-SLSL-6.4")
       (assert-yell (gt-segmentlist2-almostequal (gt-segmentlist2-simplify (gt-region2-list (gt-set2-region S 1) 1)) L1) "test-union-SLSL-6.5")
       (assert-yell (gt-segmentlist2-almostequal (gt-segmentlist2-simplify (gt-region2-list (gt-set2-region S 0) 0)) L2) "test-union-SLSL-6.6")
       )))

(define test-intersect-SLSL-1 		;two boundeds, result = 1 bounded
  (lambda ()
    (let ((L1 (gt-make-segmentlist2))
	  (L2 (gt-make-segmentlist2))
	  (S (gt-make-set2))
	  (LTest (gt-make-segmentlist2)))
      (factory-square L1 4)
      (factory-square L2 4)
      (assert-yell (gt-segmentlist2-almostequal L1 L2 #t) "test-intersect-SLSL-1.1")
      (gt-segmentlist2-translate L1 2 2) ;put radius 2 square at LL 0,0
      (gt-segmentlist2-translate L2 4 4)
      (gt-set2-intersect L1 L2 S)
      (factory-poly LTest '((2 2) (4 2) (4 4) (2 4) (2 2)))
      ;; (pk "L1" L1)
      ;; (pk "L2" L2)
      ;; (pk "S" S)
      ;; (pk "LTest" LTest)
      (assert-yell (equal? (gt-set2-numregions S) 1) "test-intersect-SLSL-1.2")
      (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 0) ) 1) "test-intersect-SLSL-1.3")
      (assert-yell (gt-segmentlist2-almostequal LTest (gt-region2-list (gt-set2-region S 0) 0)) "test-intersect-SLSL-1.4")
      )))
(define test-intersect-SLSL-2 		;two boundeds, result = 2 boundeds
  (lambda ()
    (let ((L1 (gt-make-segmentlist2))
	  (L2 (gt-make-segmentlist2))
	  (S (gt-make-set2))
	  (L-1 (gt-make-segmentlist2))
	  (L-2 (gt-make-segmentlist2)))
      (factory-poly L1 '((-2 -2) (2 -2) (2 10) (-2 10) (-2 -2)))
      (factory-poly L2 '((1 1) (10 1) (10 4) (1 4) (1 3) (4 3) (4 2) (1 2) (1 1)))
      (gt-set2-intersect L1 L2 S)
      (assert-yell (equal? (gt-set2-numregions S) 2) "test-intersect-SLSL-2.1")
      (factory-poly L-1 '((1 1) (2 1) (2 2) (1 2) (1 1)))
      (factory-poly L-2 '((1 3) (2 3) (2 4) (1 4) (1 3)))
      (assert-yell (equal? (gt-set2-numregions S) 2) "test-intersect-SLSL-2.2")
      (assert-yell (gt-segmentlist2-almostequal L-2 (gt-region2-list (gt-set2-region S 0) 0)) "test-intersect-SLSL-2.3")
      (assert-yell (gt-segmentlist2-almostequal L-1 (gt-region2-list (gt-set2-region S 1) 0)) "test-intersect-SLSL-2.4")
      )))
(define test-intersect-SLSL-3		;one bounded, one hole, result = 1 donut (bounded with a hole in it)
    ;; union of some holes
   (lambda ()
     (let ((L1 (factory-make-poly '((0 0) (6 0) (6 6) (0 6) (0 0))))
	   (L2 (factory-make-poly '((2 2) (2 4) (4 4) (4 2) (2 2))))
 	   (S (gt-make-set2)))
       (gt-set2-intersect L1 L2 S)
       ;; (pk "S" S)
       ;; (pk "numReg" (gt-set2-numregions S))
       (assert-yell (equal? (gt-set2-numregions S) 1) "test-intersect-SLSL-3.1")
       (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 0)) 2) "test-intersect-SLSL-3.2")
       (assert-yell (gt-segmentlist2-almostequal (gt-region2-list (gt-set2-region S 0) 0 ) L1) "test-intersect-SLSL-3.3")
       (assert-yell (gt-segmentlist2-almostequal (gt-region2-list (gt-set2-region S 0) 1 ) L2) "test-intersect-SLSL-3.4")
       )))
(define test-intersect-SLSL-4		;two boundeds, result = NULL_SET
    ;; union of some holes
   (lambda ()
     (let ((L1 (factory-make-poly '((0 0) (1 0) (1 1) (0 1) (0 0))))
	   (L2 (factory-make-poly '((2 2) (3 2) (3 3) (2 3) (2 2))))
 	   (S (gt-make-set2)))
       (gt-set2-intersect L1 L2 S)
       (assert-yell (equal? (gt-set2-numregions S) 0) "test-intersect-SLSL-4.1")
       )))
(define test-intersect-SLSL-5		;two holes, result = 2 holes (disjoint
    ;; union of some holes
   (lambda ()
     (let ((L1 (factory-make-poly '((0 0) (0 1) (1 1) (1 0) (0 0))))
	   (L2 (factory-make-poly '((2 2) (2 3) (3 3) (3 2) (2 2))))
 	   (S (gt-make-set2)))
       (gt-set2-intersect L1 L2 S)
       (assert-yell (equal? (gt-set2-numregions S) 1) "test-intersect-SLSL-5.1")
       (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 0)) 3) "test-intersect-SLSL-5.2")
       (assert-yell (equal? "UNBOUNDED" (gt-segmentlist2-gettype (gt-region2-list (gt-set2-region S 0) 0))) "test-intersect-SLSL-5.3")
       (assert-yell (gt-segmentlist2-almostequal (gt-region2-list (gt-set2-region S 0) 1 ) L2) "test-intersect-SLSL-5.4")
       (assert-yell (gt-segmentlist2-almostequal (gt-region2-list (gt-set2-region S 0) 2 ) L1) "test-intersect-SLSL-5.5")
       )))
(define test-intersect-SLSL-6		;two holes, result = 1 hole (overlap)
    ;; union of some holes
   (lambda ()
     (let ((L1 (factory-make-poly '((0 0) (0 5) (5 5) (5 0) (0 0))))
	   (L2 (factory-make-poly '((2 2) (2 3) (3 3) (3 2) (2 2))))
 	   (S (gt-make-set2)))
       (gt-set2-intersect L1 L2 S)
       (assert-yell (equal? (gt-set2-numregions S) 1) "test-intersect-SLSL-6.1")
       (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 0)) 2) "test-intersect-SLSL-6.2")
       (assert-yell (equal? "UNBOUNDED" (gt-segmentlist2-gettype (gt-region2-list (gt-set2-region S 0) 0))) "test-intersect-SLSL-6.3")
       (assert-yell (gt-segmentlist2-almostequal (gt-region2-list (gt-set2-region S 0) 1 ) L1) "test-intersect-SLSL-6.4")
       )))

(define test-union-RSL-1     ;donut and a bounded = result = knock out the donut hole
  (lambda ()
    (let ((R1 (gt-make-region2))
	  (L1 (factory-make-poly '((1 1) (4 1) (4 4) (1 4) (1 1))))
	  (R1Shell (factory-make-poly '((0 0) (5 0) (5 5) (0 5) (0 0))))
	  (S (gt-make-set2)))
      (gt-region2-append R1 R1Shell)
      (gt-region2-append R1 (factory-make-poly '((2 2) (2 3) (3 3) (3 2) (2 2))))
      (gt-set2-union R1 L1 S)
      (assert-yell (equal? (gt-set2-numregions S) 1) "test-union-RSL-1.1")
      (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 0)) 1) "test-union-RSL-1.2")
      (assert-yell (gt-segmentlist2-almostequal (gt-region2-list (gt-set2-region S 0) 0) R1Shell) "test-union-RSL-1.3")
      )))

(define test-union-RR-1			;two regions, output should be a donut???
  (lambda ()
    (let ((B1 (factory-make-poly '((0 0) (8 0) (8 8) (0 8) (0 0))))
	  (B2 (factory-make-poly '((1 1) (7 1) (7 7) (1 7) (1 1))))
	  (H1 (factory-make-poly '((2 2) (2 6) (6 6) (6 2) (2 2))))
	  (H2 (factory-make-poly '((3 3) (3 5) (5 5) (5 3) (3 3))))
	  (R1 (gt-make-region2))
	  (R2 (gt-make-region2))
	  (S (gt-make-set2)))
      (gt-region2-append R1 B1)
      (gt-region2-append R1 H1)
      (gt-region2-append R2 B2)
      (gt-region2-append R2 H2)
      ;; (pk "R1" R1)
      ;; (pk "R2" R2)
      (gt-set2-union R1 R2 S)
      (pk "S" S)
      )))
(define test-union-SSL-1 		;set with 2 boundeds, bounded SL, = 1 bounded total
    (lambda ()
     (let ((R1 (gt-make-region2))
	   (L1 (factory-make-poly '((1 0) (5 0) (5 2) (1 2) (1 0))))
 	   (S (gt-make-set2))
	   (LResult (factory-make-poly '((0 0) (6 0) (6 1) (0 1) (0 0)))))
       (gt-region2-append R1 (factory-make-poly '((0 0) (2 0) (2 1) (0 1) (0 0))))
       (gt-region2-append R1 (factory-make-poly '((4 0) (6 0) (6 1) (4 1) (4 0))))
       (gt-set2-union R1 L1 S)
       (assert-yell (equal? (gt-set2-numregions S) 1) "test-union-RSL-1.1")
       (assert-yell (equal? (gt-region2-numlists (gt-set2-region S 0)) 1) "test-union-RSL-1.2")
       (assert-yell (gt-segmentlist2-almostequal (gt-region2-list (gt-set2-region S 0) 0) LResult) "test-union-RSL-1.3")
       )))


(define test-expand-SL-1
  (lambda ()
    (let ((L1 (factory-make-rectangle 2 1))
	  (res (gt-make-set2)))
      (gt-segmentlist2-translate L1 1 0.5)
      (pk "exp pre" L1)
      (gt-set2-expand L1 0.5 res)
      (pk "exp res" res))))

(define run-tests
  (lambda ()
    (newline)
    (newline)
    (display "running some tests now")
    (newline)
    (test-union-SLSL-1)
    (test-union-SLSL-2)
    (test-union-SLSL-3)
    (test-union-SLSL-4)
    (test-union-SLSL-5)
    (test-union-SLSL-6)

    (test-intersect-SLSL-1)
    (test-intersect-SLSL-2)
    (test-intersect-SLSL-3)
    (test-intersect-SLSL-4)
    (test-intersect-SLSL-5)
    (test-intersect-SLSL-6)

    (test-union-RSL-1)

    (test-expand-SL-1)
    (pk "tests ok? " tests-ok)))

(run-tests)
(pk "tests ok? " tests-ok)




;; (define L1 (gt-make-segmentlist2))
;; (define L2 (gt-make-segmentlist2))
;; (define S (gt-make-set2))
;; (define LTest (gt-make-segmentlist2))

;; (factory-square L1 4)
;; (factory-square L2 4)
;; (assert-yell (gt-segmentlist2-almostequal L1 L2 #t) "test-union-SLSL-1")
;; (gt-segmentlist2-translate L1 2 2) ;put radius 2 square at LL 0,0
;; (gt-segmentlist2-translate L2 4 4) ;put radius 2 square at LL 1,1
;; (gt-set2-union L1 L2 S)
;; (display "the Set\n")
;; (pk S)
;; (display "the region0\n")
;; (pk (gt-set2-region S 0))
;; (display "the seglist0 of region0\n")
;; (pk (gt-region2-list (gt-set2-region S 0) 0))
;; (gt-segmentlist2-append LTest (gt-make-line2 0 0 4 0))
;; (gt-segmentlist2-append LTest (gt-make-line2 4 0 4 2))
;; (gt-segmentlist2-append LTest (gt-make-line2 4 2 6 2))
;; (gt-segmentlist2-append LTest (gt-make-line2 6 2 6 6))
;; (gt-segmentlist2-append LTest (gt-make-line2 6 6 2 6))
;; (gt-segmentlist2-append LTest (gt-make-line2 2 6 2 4))
;; (gt-segmentlist2-append LTest (gt-make-line2 2 4 0 4))
;; (gt-segmentlist2-append LTest (gt-make-line2 0 4 0 0))
;; (display "and this is the test list\n")
;; (pk LTest)


;; (define LTest (gt-make-segmentlist2))
;; ;; (factory-poly LTest (list (list 0 0) (list 4 0) (list 4 4) (list 0 4) (list 0 0)))
;; (factory-poly LTest '((0 0) (4 0) (4 4) (0 4) (0 0)))
